# SQL-QUERY-LEXER-PARSER

This project implements a simple SQL query lexer and parser using **Flex** (lex) and **Bison** (yacc) to analyse SQL query strings. It can be used as a foundation for building your own SQL-engine, query validator, translator or database front-end.

## Table of Contents

* [Features](#features)
* [Prerequisites](#prerequisites)
* [Directory Structure](#directory-structure)
* [Build Instructions](#build-instructions)
* [Usage](#usage)
* [How it works](#how-it-works)
* [Extending the grammar](#extending-the-grammar)
* [License](#license)

## Features

* Lexical analysis of SQL keywords, identifiers, numbers, strings, operators using Flex.
* Parsing of SQL queries (basic SELECT/INSERT/UPDATE/DELETE style) using Bison.
* Generation of a parse tree (or simple semantic actions) on recognized queries.
* Makefile to build the project easily.

## Prerequisites

* A Unix-like environment (Linux, macOS).
* Flex (lex) installed.
* Bison (yacc) installed.
* A C compiler (gcc or clang).
* Make utility.

You can install dependencies on Debian/Ubuntu via:

```bash
sudo apt update
sudo apt install flex bison build-essential
```

You can install dependencies on MacOS via:
```bash
brew install flex bison
```
You can check version with these commands:
```
flex --version
bison --version
```

## Directory Structure

```
.
├── makefile
├── lex.yy.c                         ← generated by Flex
├── sql_query_parser_bison.tab.c     ← generated by Bison
├── sql_query_parser_bison.tab.h     ← generated by Bison
├── sql_query_parser_bison.y         ← Bison grammar file
└── sql_query_parser_flex.l          ← Flex lexer specification
```

* `sql_query_parser_flex.l` – your Flex rules for tokens (keywords, identifiers, numbers, strings, operators).
* `sql_query_parser_bison.y` – your Bison grammar file for SQL queries: grammar rules, precedence, semantic actions.
* `makefile` – automates generation of lexer & parser and compilation into an executable.

## Build Instructions

To build the lexer/parser, run:

```bash
make
```

What `make` does:

1. Runs Flex:

   ```bash
   flex sql_query_parser_flex.l
   ```

   producing `lex.yy.c`.

2. Runs Bison:

   ```bash
   bison -d sql_query_parser_bison.y
   ```

   producing `sql_query_parser_bison.tab.c` and `sql_query_parser_bison.tab.h`.

3. Compiles the C code:

   ```bash
   gcc -o sql_parser lex.yy.c sql_query_parser_bison.tab.c -lfl
   ```

   (Note: `-lfl` links the libfl library for Flex; on some systems this may vary.)

4. This generates the executable `sql_parser`.

## Usage

Once built, use the parser like:

```bash
./sql_parser "SELECT name, age FROM users WHERE age > 30;"
```

It will parse the SQL string, report syntax errors (if any) and on success can output a parse tree or a success message. You can also run input from a file:

```bash
./sql_parser < sample_queries.sql
```

## How it Works

### 1. Lexical Analysis (Flex)

The Flex file (`sql_query_parser_flex.l`) defines patterns for tokens such as:

* Keywords: SELECT, FROM, WHERE, INSERT, UPDATE, DELETE, etc.
* Identifiers: table names, column names.
* Literals: numeric constants, string literals.
* Operators: `=`, `<`, `>`, `<=`, `>=`, `<>`, `+`, `-`, `*`, `/`.
* Punctuation: `,`, `;`, `(`, `)`, `.`.

Flex matches input to tokens and returns the token type to Bison, optionally setting `yylval`.

### 2. Parsing / Grammar (Bison)

The Bison file (`sql_query_parser_bison.y`) defines grammar rules for SQL queries, for example:

```
query: select_stmt ';'
     | insert_stmt ';'
     | update_stmt ';'
     | delete_stmt ';' ;
```

Semantic actions (C code inside `{ ... }`) can build an AST or print debug info.

### 3. Semantic Actions & Error Handling

Bison reports syntax errors; you can customize error messages, add recovery rules, or create structured AST nodes.

## Extending the Grammar

You can extend functionality by:

* Adding new SQL statements: `CREATE TABLE`, `DROP`, `ALTER`, etc.
* Supporting JOINs, subqueries, `GROUP BY`, `ORDER BY`, functions like `COUNT()`.
* Generating a full AST instead of print logs.
* Linking to a backend DB or transpiling to another query language.
* Improving error recovery and adding user-friendly error messages.
* Writing unit tests to validate different SQL inputs.

## Tips

* When modifying `.y` or `.l` files, run `make clean && make`.
* Keep more specific Flex rules above general patterns.
* Distinguish keywords from identifiers for correct parsing.
* Free memory for AST nodes if building a full tree (avoid leaks).

## License

This project is released under the MIT License — see the `LICENSE` file for details.

---

Feel free to contribute! Open issues or submit PRs to enhance this SQL parser.

